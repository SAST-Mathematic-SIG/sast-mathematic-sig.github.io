[{"id":0,"href":"/docs/contribute_helper/","title":"贡献须知","section":"Docs","content":" 贡献须知 # 该板块记录一些关于本站的一些基本信息，这些信息会为您为本站提交文档做出帮助\n目前完成部分：\n文档编写教程 "},{"id":1,"href":"/menu/","title":"Index","section":"Introduction","content":" 贡献须知 本站文档编写教程 基础markdown语法 本站扩展语法——shortcodes "},{"id":2,"href":"/posts/subtyping_variance_and_its_application/","title":"Subtyping variance and its application","section":"博客","content":"子类型型变及其应用\n无类型lambda演算 # 无类型lambda演算含有以下三个组成部分\nterm \\( t \\) abstraction \\( λx.t \\) application \\( t_1\\ t_2 \\) Example 1 # $$ \\begin{aligned} \u0026amp; (λx.x) ((λx.x) (λz. (λx.x) z)) \\\\ \\rightarrow \u0026amp; (λx.x) ((λx.x) (λz.z)) \\\\ \\rightarrow \u0026amp; (λx.x) (λz.z) \\\\ \\rightarrow \u0026amp; (λz.z) \\\\ \\rightarrow \u0026amp; (λx.x) \\\\ \\end{aligned} $$\n简单类型lambda演算 # 简单类型lambda演算( \\( \\lambda_{\\rightarrow} \\) )含有以下五个组成部分\nterm \\( t \\) abstraction \\( λx.t \\) application \\( t_1\\ t_2 \\) type of functions \\( T_1\\rightarrow T_2 \\) typing context \\( \\Gamma \\) Example 2 # $$ \\dfrac{\\dfrac{\\Gamma, x: T_1 \\vdash t_1: T_2}{\\Gamma \\vdash \\lambda x: T_1. t_1: T_1 \\to T_2} \\quad \\quad \\genfrac{}{}{0pt}{0}{}{\\Gamma \\vdash t_2: T_1}}{\\Gamma \\vdash \\left(\\lambda x: T_1. t_1\\right) \\ t_2: T_2} $$\n含有子类型的简单类型lambda演算 # \\( \u0026lt;: \\) 笑脸可爱捏\n相比简单类型lambda演算( \\( \\lambda_{\\rightarrow} \\) )，唯独多出一个子类型( \\( \\lambda_{\u0026lt;:} \\) )的运算:\nsubtyping \\( S \u0026lt;: T \\) 如果 S 是 T 的子类型，意思是在任何需要使用 T 类型对象的环境中，都可以安全地使用 S 类型的对象。\n子类型的性质 # reflexive | 自反性 : \\( S \u0026lt;: S \\) transitive | 传递性 : \\( \\dfrac{S \u0026lt;: U \\qquad U \u0026lt;: T}{S \u0026lt;: T}\\ \\) top and bottom | 上界与下界 : \\( \\text{Bot} \u0026lt;: S \u0026lt;: \\text{Top} \\) 目前为止还没有什么证明，要说明这里的第一条和第二条都很好理解，第三条是指上界和下界的存在性\n子类型型变 # 这其实也是指的一组性质\ncovariant | 协变 $$ \\dfrac{S \u0026lt;: T}{\\text{list of } S \u0026lt;: \\text{list of } T} $$ contravariant | 逆变 $$ \\dfrac{S \u0026lt;: T}{T \\to U \u0026lt;: S \\to U} $$ invariant | 不变 $$ \\dfrac{S \u0026lt;: T}{S \\to S \\text{ is neither subtype nor supertype of } T \\to T} $$ 这里也是，协变和不变的性质很好理解，但逆变的性质就不是很好理解了\n接下来将对逆变给出一个并不严格的证明，或者说是说明\ncontravariant | 逆变：\n翻译一下，S 是 T 的子类型，那么 “T到U的函数” 这个类型是 “S到U的函数” 这个类型的子类型\n根据我们之前所提到的子类型的含义和逆变性质，我们现在来思考一下是否在任何需要使用 “S到U的函数” 类型对象的环境中，都可以安全地使用 “T到U的函数” 类型的对象。\n从逻辑上来说并没有问题，根据多态，我需要用到 “S到U的函数” 的环境其实最后就是为了代入函数求值，但其实能代入 S 的实例化对象求值的场景，你把这个 “S到U的函数” 换成 “T到U的函数” 也能正常跑，完全没有任何问题\n应用: Rust 类型系统的生命周期 # 观察如下一小段 Rust 代码\n{ let foo: \u0026amp;u8 = \u0026amp;1; { let bar = \u0026amp;foo; println!(\u0026#34;bar = {}\u0026#34;, **bar); } } 熟悉 Rust 的朋友有可能在学习使用生命周期的时候接触过这段代码，但为了给更多人讲解，先让我们给它标记上更明显的生命周期标签\nWARNING: 下面这一段代码是一段伪代码，Rust 编译器将不能编译它\n\u0026#39;b: { let foo: \u0026amp;\u0026#39;b u8 = \u0026amp;1; \u0026#39;a: { let bar: \u0026amp;\u0026#39;a \u0026amp;\u0026#39;b u8 = \u0026amp;foo; println!(\u0026#34;bar = {}\u0026#34;, **bar); } } 此时此刻可以看到我们给外部作用域起一个生命周期的标签为 'b ，当然这里的标签是不能写在作用域前的，实际上被写在了第二行的 foo 变量的初始化中，这个标记意味着 foo 这个引用的生命周期是 'b ，而 bar 变量也是一样的，只是这边要强调一个点：\u0026amp;'a \u0026amp;'b u8 这个是引用的引用，隐式的要求 'a 要满足最多生命周期和 'b 一样长\n那这和我们上面的子类型有什么关系呢，我们看第二行：let foo: \u0026amp;'b u8 = \u0026amp;1; ，其中 \u0026amp;1 的生命周期在 Rust 中被规定为 'static 所以 \u0026amp;1 的类型其实是 \u0026amp;'static u8 ，而 \u0026amp;'static u8 可以赋给 \u0026amp;'b u8 ，是为 \u0026amp;'static u8 为 \u0026amp;'b u8 的子类型\n总结以下，在这里 Bot = \u0026amp;'static T \u0026lt;: \u0026amp;'b T \u0026lt;: \u0026amp;'a T\n接下来我们要提 Rust 中利用生命周期造就的经典的类型分析器的漏洞，在本文发布的时间点(2024.8.19)还未被修复\nOops!\nstatic UNIT: \u0026amp;\u0026#39;static \u0026amp;\u0026#39;static () = \u0026amp;\u0026amp;(); fn foo\u0026lt;\u0026#39;a, \u0026#39;b, T\u0026gt;(_: \u0026amp;\u0026#39;a \u0026amp;\u0026#39;b (), v: \u0026amp;\u0026#39;b T) -\u0026gt; \u0026amp;\u0026#39;a T { v } fn bad\u0026lt;\u0026#39;a, T\u0026gt;(x: \u0026amp;\u0026#39;a T) -\u0026gt; \u0026amp;\u0026#39;static T { let f: fn(_, \u0026amp;\u0026#39;a T) -\u0026gt; \u0026amp;\u0026#39;static T = foo; f(UNIT, x) } 可以看到 bad 函数很神奇的传入了一个 \u0026amp;'a T 类型的 x 却返回了 \u0026amp;'static T 的 x，这可了不得，这意味着你可以将一个引用的生命周期无端的延长，想象一下，这将不可避免的造成引用空悬，内存安全也就不存在了。众所周知，Rust 的一大亮点就是安全，但这段神奇的代码居然能“安全”的过编译\n让我们来看看它是怎么工作的\nfn foo\u0026lt;\u0026#39;a, \u0026#39;b, T\u0026gt;(_: \u0026amp;\u0026#39;a \u0026amp;\u0026#39;b (), v: \u0026amp;\u0026#39;b T) -\u0026gt; \u0026amp;\u0026#39;a T fn foo\u0026lt;\u0026#39;a, \u0026#39;b, T\u0026gt;(_: \u0026amp;\u0026#39;a \u0026amp;\u0026#39;static (), v: \u0026amp;\u0026#39;b T) -\u0026gt; \u0026amp;\u0026#39;a T fn foo\u0026lt;\u0026#39;b, T\u0026gt;(_: \u0026amp;\u0026#39;static \u0026amp;\u0026#39;static (), v: \u0026amp;\u0026#39;b T) -\u0026gt; \u0026amp;\u0026#39;static T 上面这3行揭示了编译器在进行转换时发生的几个步骤：第一行是我们原来 foo 的标签，编译器首先将他转化为第二行，\u0026amp;'a \u0026amp;'b () 转化为 \u0026amp;'a \u0026amp;'static () ，因为 \u0026amp;'a \u0026amp;'static () 是 \u0026amp;'a \u0026amp;'b () 的子类型，那么根据逆变规则，这里的第一行的签名就是第二行的子类型，那么在任何需要使用第二行类型对象的环境中，都可以安全地使用第一行类型的对象。那么编译器便试图创建第二行的环境(因为你写的是 _ ，要编译器去推导)，以适应你的 foo ，但是此时此刻，你告诉编译器 'a 是 'static ，编译器直接懵了，那就替换吧，于是借了编译器之手成就了天才的Lifetime_Expansion\n那么如何规避这个问题呢，其实关键就是这当中丢失了一个关键因素：第一行到第二行的时候丢失了一个 \u0026amp;'a \u0026amp;'b () 包含的隐式的信息：'a 应该生命周期短于 'b ，而转化到第二步恰恰丢失了这一步信息，'a 和 'b 完全是两个无关的生命周期标签了\n所以只要我们再给编译器一点提示，不至于让他绕进去就好了:\n//Manual solution fn foo\u0026lt;\u0026#39;a, \u0026#39;b, T\u0026gt;(_: \u0026amp;\u0026#39;a \u0026amp;\u0026#39;b (), v: \u0026amp;\u0026#39;b T) -\u0026gt; \u0026amp;\u0026#39;a T where \u0026#39;b: \u0026#39;a 当我们告诉编译器 'b 与 'a 之间的偏序关系，即表示 'b 至少要活得跟 'a 一样久。\n值得注意的是，这只是一个类型分析器的 bug ，当你试图将 _ 省略的内容写清楚，也会使得这个 bug 消除\ncve-rs 正是利用了这点，在完全不含 unsafe 块的 Rust 代码中引入了 segmentfault 等内存错误，这太有乐子了。\n作者：Github @NKID00\n增改：Github @feipiao594\n参考文献：\n[1]. Github repo: cve-rs https://github.com/Speykious/cve-rs\n"},{"id":3,"href":"/posts/an_abstract_guide_to_type_abstraction/","title":"一份抽象的类型抽象指北","section":"博客","content":" 内存本非数，类型亦无形。编译不报错，运行未必行。\n程序设计常常涉及类型的抽象。你是否在一些库的文档中看过各种类型，却觉得它们过于抽象？动辄几十几百个成员的枚举类型，总是报错的类型约束，永远设计不出的 trait，以及程序运行时无尽的 panic……看完今天的介绍，不说你是醍醐灌顶，至少也算得上是毫无收获。\n引子 # 除法 # 以下是一个常见的除法定义，采用 Rust 语言，以 u32 类型为例：\nfn div(a: u32, b: u32) -\u0026gt; u32 { a / b } fn main() { div(6, 3); // 2 div(5, 1); // 5 div(4, 0); // panic! } 函数明明定义为 fn(u32, u32) -\u0026gt; u32，但却不一定总能返回 u32 类型的值。这是一种意外行为（虽然你大概也许知道 0 不能作为除数，所以你可能或许毫不意外）。\n虽然 Rust 标准库文档说明了除法可能 panic，但是正经人谁看文档啊，下贱，但是文档里面的备注容易被忽略，而这种把潜在错误留到运行时的行为很容易导致意外崩溃。\n对此，我们可以用两种方法在类型层面解决：\n限制除数类型为非零整数，如采用 NonZero\u0026lt;u32\u0026gt; 类型： 相当于定义：\nfn div(a: u32, b: NonZero\u0026lt;u32\u0026gt;) -\u0026gt; u32 { a / b.get() } 运行时检查可能的错误，返回可能失败的结果，如 checked_div 函数：\n颜色 # 如何定义 Color 类型？\nString？（\u0026quot;black\u0026quot;、\u0026quot;white\u0026quot;、\u0026quot;red\u0026quot;、\u0026quot;rgb(0 0 255)\u0026quot;、\u0026quot;#00FF00\u0026quot;……）\nRGB (u8, u8, u8)（真彩色）？\nRGBA (u8, u8, u8, u8)？\nf32？f64？\n16 色？256 色（u8）？\n0bRRRGGGBB？\nANSI？\nANSI 256 色:\nany？\n人眼所能看见的颜色范围很广，但是计算机对颜色的表示（颜色空间）只能覆盖人眼可见颜色的一部分。以下是常见的颜色空间对比：\n你永远无法定义一个完美的 Color 类型！适合使用场景的类型才是最好的类型。\n以浏览器渲染流程为例，一个可能的类型工作流程是：\n在处理原始 CSS 颜色字符串时，使用 String\nCSS 解析后可以转为自定义的 enum 类型，类似于：\n/// Number range is extracted from /// \u0026lt;https://drafts.csswg.org/css-color/#color-type\u0026gt; #[non_exhaustive] enum Color { Transparent, Named(NamedColor), Hex(u32), // 0xRRGGBBAA Rgb(f32, f32, f32), // 0.0..=255.0 Rgba(f32, f32, f32, f32), // R/G/B: 0.0..=255.0, A: 0.0..=1.0 Hsl(f32, f32, f32), // H: 0.0..360.0, S/L: 0.0..100.0 Hsla(f32, f32, f32, f32), // Hwb, Lab, Lch, etc. } 内部可以表示为 RGBA 或其他颜色空间\n处理完透明度混合后，最终渲染到像素点时采用 RGB\n错误类型 # 在一个项目（crate）中，如何定义错误类型？\nString？（简单明了，但不够规范，难以本地化处理） Box\u0026lt;dyn Error\u0026gt;？anyhow::Error？（与 String 相比，规范了输出格式，但仍不够结构化，适合 bin crate） enum + #[derive(thiserror::Error)]？（结构化程度更高，但需要额外设计错误类型，适合 lib crate） any？ 好的类型抽象有哪些特点？ # 好的类型抽象应该抽象\n类型本质是一种集合。好的类型应该和良好定义的集合具有相似的性质。\n高中的数学课介绍了集合的三大性质：\n确定性：对于任意一个元素，它要么属于这个集合，要么不属于这个集合。 互异性：集合中的元素是互不相同的。 无序性：集合中的元素之间没有顺序关系。 其中无序性主要用于集合相等性的判定，不在这里讨论。\n对于确定性的要求，好的抽象应该满足：\n任何合法的概念都能以这个类型的值来表示。 任何非法的概念不能以这个类型的值来表示。 对于互异性的要求，好的抽象应该满足：\n在该类型的框架下，一个合法的概念只能有一种表示方式。 或者说，好的类型抽象和被抽象的概念同构（一一对应）。\n同时，好的类型抽象应该尽可能简单，不应该包含多余的信息。\n实战：任务调度 # 了解 typestate 设计模式。具体代码可见 type-abstraction 仓库。\n作者: Github: @Jisu-Woniu\n"},{"id":4,"href":"/docs/contribute_helper/documentation_writing_tutorials/submit_documents_using_pr/","title":"使用pull request提交文档","section":"文档编写教程","content":" 使用pull request提交文档 # 本站部署基于 SAST-Mathematics-SIG 下的三个Github仓库\nMathematics_SIG_Blog: *.md 文档全都置于这个仓库中 blog_deploy_source: 一些 Blog 配置相关的仓库 sast-mathematics-sig.github.io: github page部署使用的仓库 采用这样的方案主要是为了让配置文件和文档本身分离，当你需要提交你的文档时，你需要\nfork Mathematics_SIG_Blog仓库 在本地对这个仓库的内容进行修改 向上游仓库提起 pull request ，等待我们的回应 pull request 合入仓库，你的文档就能正常的在网页上显示了 pull request 教程 # 当你对本地 fork 的仓库进行了一些修改之后，你的仓库是长这样的 点击 Contribute ，并点击 Open pull request 接着你就可以进入提交 pr 的界面了，注意，请你指定一个 Reviewer 来检查你的提交，Assignees 请你指定你自己\n创建完成后，你可以在仓库的 pull request 处看见自己提交的 pr，你需要等待 Reviewer 检查后方可合入\n"},{"id":5,"href":"/docs/contribute_helper/documentation_writing_tutorials/basic_markdown_syntax/","title":"基础markdown语法","section":"文档编写教程","content":" 基础markdown语法 # Markdown 是一种轻量级的“标记语言”，由 John Gruber 于 2004 年创建，Markdown 的语法十分简单，正是因为其轻量化的特点，才被众多写作爱好者广泛应用\n前排提醒: 本文档只是搬运基本的 Markdown 语法并对其简单介绍，并不完整详尽的叙述 Markdown 的各种扩展功能，也不会探讨 Markdown 语法解析等高级内容，预知详情请移步至官方网站 前言 # 首先， Markdown 用于在纯文本文档中添加格式化元素，这意味着它只是将一份纯文本文档，加以一些标记使得其中的一部分内容会被特殊化的处理而已\n在使用 Markdown 格式书写时，文本内容存储在带有 .md 或 .markdown 扩展名的纯文本文件中\n例如 test.md ，你可以在里面像 .txt 一样书写文字，比如你写了一篇文章，标题title独占一行，在 Markdown 中，你可以将 title 改为 # title ，保存后，将该文本文件交由 arkdown 处理器（也通常称为“解析器”或“实现”）的东西将获取到的 Markdown 格式的文本输出为 HTML 格式，接着你就会发现你的 # title 会被其对应成为一个一级标题\n工具推荐 # 书写 Markdown 可以使用 Typora ，同样被推荐的是 vscode 的 markdown all in one 插件\n基本语法 # 到了正片，接下来是简单的介绍基本语法的时间\n标题语法 # 在某一行的开头使用 # 创建标题，使用n个井号意为 n 级标题，例如\n# 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 注意到井号串后方需要加一个空格，这是出于兼容性的合理考虑\n段落 # Markdown中的段落是指一段话和一段话之间固定的分隔，要想实现这个，需要在两段话中添加空白行\n不要在段落的开头使用空格和tab制表符来缩进 换行 # 在一行的末尾添加两个或多个空格，然后按回车键,即可创建一个换行，注意和上面所说的段落不相同，这里的换行还是属于同一个段落的\n强调 # 强调分为粗体与斜体\n上面这句话就是一个最好的例子，使用单星号包裹文字为斜体，双星号为粗体\n强调分为**粗体**与*斜体* 而如果需要同时用粗体和斜体突出显示文本，需在单词或短语的前后各添加三个星号或下划线。\n以下均为粗斜体 ***1*** _**2**_ __*3*__ ___4___ 要加粗并用斜体显示单词或短语的中间部分，请在要突出显示的部分前后各添加三个星号，中间不要带空格\nThis is really***very***important text. 引用 # 要创建块引用，请在段落前添加一个 \u0026gt; 符号 块引用可以包含多个段落。为段落之间的空白行添加一个 \u0026gt; 符号 块引用可以嵌套。在要嵌套的段落前添加一个 \u0026gt;\u0026gt; 符号 块引用可以包含其他 Markdown 格式的元素。但并非所有元素都可以使用\n\u0026gt; 123 \u0026gt; 123 \u0026gt; \u0026gt; 456 \u0026gt; 123 \u0026gt;\u0026gt; 456 \u0026gt; 789 列表 # 向下面这样用序号与缩进创建有序列表，用破折号-、星号*或加号+创建无序列表\n1. 2. 3. 1. 2. 4. - - - - - Use `code` in your Markdown file.\n代码 # 要将单词或短语表示为代码，请将其包裹在反引号 (`) 中。 要创建代码块，请将代码块的每一行缩进至少四个空格或一个制表符。\n分割线 # 在某一行写超过三个---创建分割线 效果演示如下，为了兼容性，请在分隔线的前后均添加空白行。\n图片 # 语法如下\n![photo alt](photo url \u0026#34;photo title\u0026#34;) 如果你要给图片增加链接，请将图像的Markdown 括在方括号中，然后将链接添加在圆括号中。\n[![photo alt](photo url \u0026#34;photo title\u0026#34;)](link url) 链接 # 以下是创建一个链接基本的语法，只会显示一个连接的名字，例如本站首页\n[本站首页](https://sast-mathematic-sig.github.io) 如果要设置一个鼠标放在上面悬浮的标签的话语法如下，例如本站首页\n[本站首页](https://sast-mathematic-sig.github.io \u0026#34;数学SIG首页\u0026#34;) 快捷创建一个链接可以用\u0026lt;\u0026gt;包裹一个url或者email\n强调链接, 在链接语法前后增加星号。要将链接表示为代码，请在方括号中添加反引号。\n参考文献 # [1]. Markdown 官方教程 https://markdown.com.cn/\n"},{"id":6,"href":"/docs/contribute_helper/documentation_writing_tutorials/","title":"文档编写教程","section":"贡献须知","content":" 文档编写教程 # 这一部分有助于您更好的向这个网站提交您的内容\n您可能需要的基本信息 # 首先需要了解我们这个网站的基本信息，该网站部署在Github Page，这是一个可以直接从GitHub存储库托管的网页，而GitHub是一个共享和贡献开源软件的流行平台，您可以把代码存储在它所提供的仓库中，我们的网页正是由这样的仓库所构建成的\nINFO: GitHub中大量使用Git作为版本控制工具，如果您不知道Git是什么，您只须知道Git可以往您的仓库中提交内容 在这个网站中每一份文档都是用Markdown书写，这是一种轻量的标记语言，其实就是在普通文本的基础上稍作渲染，使用它可以完成简单的记笔记等工作，也正是如此，博客等性质的文字很适合使用Markdown来写\n您可能需要的教程 # 由上一部分可知，想要提交您的文档，您需要了解\nMarkdown的基本语法，熟练使用Markdown进行文档编写： 基础markdown语法 本站扩展语法——shortcodes GitHub的使用，学会使用Git： 如何向仓库提交PR "},{"id":7,"href":"/docs/contribute_helper/documentation_writing_tutorials/extend_markdown_syntax/","title":"本站扩展语法","section":"文档编写教程","content":" 本站扩展语法——shortcodes # 本站使用hugo与hugo-book搭建，支持一些称之为shortcodes的markdown扩展语法，接下来我们就详细介绍一下\n按钮 # 按钮其实是一个装饰后的超链接，它可以导向外部连接或者本地\n例子 # {{\u0026lt; button relref=\u0026#34;/\u0026#34; [class=\u0026#34;...\u0026#34;] \u0026gt;}}回到首页{{\u0026lt; /button \u0026gt;}} {{\u0026lt; button href=\u0026#34;https://github.com/SAST-Mathematics-SIG\u0026#34; \u0026gt;}}前往SIG的GITHUB组织{{\u0026lt; /button \u0026gt;}} 回到首页 前往SIG的GITHUB组织 细节展示 # 细节展示(Details)是一个展开的栏目，可以隐藏一些信息\n例子 # {{\u0026lt; details \u0026#34;Title\u0026#34; [open] \u0026gt;}} ### 内容 细节展示(Details)是... {{\u0026lt; /details \u0026gt;}} {{\u0026lt; details title=\u0026#34;Title\u0026#34; open=true \u0026gt;}} ### 内容 细节展示(Details)是... {{\u0026lt; /details \u0026gt;}} Title 内容 # 细节展示(Details)是\u0026hellip;\n分列 # 分列(Columns)有助于组织简短的文字，使之排版更加清晰可读\n{{\u0026lt; columns \u0026gt;}} \u0026lt;!-- begin columns block --\u0026gt; # Left Content Lorem markdownum insigne... \u0026lt;---\u0026gt; \u0026lt;!-- magic separator, between columns --\u0026gt; # Mid Content Lorem markdownum insigne... \u0026lt;---\u0026gt; \u0026lt;!-- magic separator, between columns --\u0026gt; # Right Content Lorem markdownum insigne... {{\u0026lt; /columns \u0026gt;}} 例子 # 左段落 # 左段落内容\u0026hellip;\n#include \u0026lt;iostream\u0026gt; int main(){ std::cout \u0026lt;\u0026lt;\u0026#34;hello world\u0026#34;; } 中段落 # 中段落内容\u0026hellip;\nWARNING: 注意在分栏中不能使用扩展语法\n右段落 # 右段落内容\u0026hellip;\nSAST.Mathematics SIG\n高亮 # 高亮是一种不同颜色的引用块， 有三种颜色可以被选择: info, warning and danger.\n{{\u0026lt; hint [info|warning|danger] \u0026gt;}} **内容** 这里是*[info|warning|danger]*喵 {{\u0026lt; /hint \u0026gt;}} 例子 # 内容\n这里是 Info 喵 内容\n这里是 warning 喵 内容\n这里是 danger 喵 KaTeX # KaTeX 可以让你在Markdown中插入Latex公式，在本站相当重要。详情可见 KaTeX\n{{\u0026lt; katex \u0026gt;}}\\pi(x){{\u0026lt; /katex \u0026gt;}} //这是行内公式 {{\u0026lt; katex display=true class=\u0026#34;optional\u0026#34; \u0026gt;}} f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi {{\u0026lt; /katex \u0026gt;}} // 这是行外公式 注意 对于行外公式，你也可以使用markdown自带的写法，甚至更加推荐这种写法\n$$a^2+b^2=c^2$$ $$a^2+b^2=c^2$$\n显示模式/例子 # 这里是行内公式: \\(\\pi(x)\\) 下面是行外公式, 具有display: block属性\n\\[f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi\\] 文本可以在这里继续\ntabs # tabs 有助于你组织不同情况下不同的文本\n{{\u0026lt; tabs \u0026#34;uniqueid\u0026#34; \u0026gt;}} {{\u0026lt; tab \u0026#34;MacOS\u0026#34; \u0026gt;}} # MacOS Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; tab \u0026#34;Linux\u0026#34; \u0026gt;}} # Linux Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; tab \u0026#34;Windows\u0026#34; \u0026gt;}} # Windows Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; /tabs \u0026gt;}} Example # MacOS MacOS # 这是 MacOS 的tab内容\nSAST.Mathematics SIG\nLinux Linux # 这是 Linux 的tab内容\nSAST.Mathematics SIG\nWindows Windows # 这是 Windows 的tab内容\nSAST.Mathematics SIG\nMermaid 图表 # MermaidJS 是用于从文本生成 svg 图表和图表的库\n覆盖Mermaid的初始化配置\n要覆盖 Mermaid 的初始化配置，请在 assets 文件夹中创建一个 mermaid.json 文件！\n例子 # {{\u0026lt; mermaid class=\u0026#34;optional\u0026#34; \u0026gt;}} stateDiagram-v2 State1: The state with a note note right of State1 Important information! You can write notes. end note State1 --\u0026gt; State2 note left of State2 : This is the note to the left. {{\u0026lt; /mermaid \u0026gt;}} stateDiagram-v2 State1: The state with a note note right of State1 Important information! You can write notes. end note State1 --\u003e State2 note left of State2 : This is the note to the left. "}]