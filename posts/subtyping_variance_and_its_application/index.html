<!doctype html><html lang=zh-CN dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="子类型型变及其应用"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://example.org/posts/subtyping_variance_and_its_application/"><meta property="og:site_name" content="SAST.Mathematics SIG"><meta property="og:title" content="Subtyping variance and its application"><meta property="og:description" content="子类型型变及其应用"><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:tag" content="Rust"><meta property="article:tag" content="Type"><title>Subtyping variance and its application | SAST.Mathematics SIG</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=https://example.org/posts/subtyping_variance_and_its_application/><link rel=stylesheet href=/book.min.309b7ed028807cdb68d8d61e26d609f48369c098dbf5e4d8c0dcf4cdf49feafc.css integrity="sha256-MJt+0CiAfNto2NYeJtYJ9INpwJjb9eTYwNz0zfSf6vw=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script><script defer src=/en.search.min.7545db621b859fca3c4f21040717d759270f3349749ffabc9b021c0a67dfdfa4.js integrity="sha256-dUXbYhuFn8o8TyEEBxfXWScPM0l0n/q8mwIcCmff36Q=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>SAST.Mathematics SIG</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><a href=/docs/contribute_helper/>贡献须知</a><ul><li><input type=checkbox id=section-f5e825ff929e2b2f77518c193983bdca class=toggle>
<label for=section-f5e825ff929e2b2f77518c193983bdca class="flex justify-between"><a href=/docs/contribute_helper/documentation_writing_tutorials/>文档编写教程</a></label><ul><li><a href=/docs/contribute_helper/documentation_writing_tutorials/submit_documents_using_pr/>使用pull request提交文档</a><ul></ul></li><li><a href=/docs/contribute_helper/documentation_writing_tutorials/basic_markdown_syntax/>基础markdown语法</a></li><li><a href=/docs/contribute_helper/documentation_writing_tutorials/extend_markdown_syntax/>本站扩展语法</a></li></ul></li></ul></li></ul><ul><li><a href=/posts/>博客</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Subtyping variance and its application</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#无类型lambda演算>无类型lambda演算</a><ul><li><a href=#example-1>Example 1</a></li></ul></li><li><a href=#简单类型lambda演算>简单类型lambda演算</a><ul><li><a href=#example-2>Example 2</a></li></ul></li><li><a href=#含有子类型的简单类型lambda演算>含有子类型的简单类型lambda演算</a><ul><li><a href=#子类型的性质>子类型的性质</a></li></ul></li><li><a href=#子类型型变>子类型型变</a></li><li><a href=#应用-rust-类型系统的生命周期>应用: Rust 类型系统的生命周期</a></li></ul></nav></aside></header><article class="markdown book-post"><h1><a href=/posts/subtyping_variance_and_its_application/>Subtyping variance and its application</a></h1><div><a href=/categories/type-theory/>Type Theory</a></div><div><a href=/tags/rust/>Rust</a>,
<a href=/tags/type/>Type</a></div><p>子类型型变及其应用</p><h2 id=无类型lambda演算>无类型lambda演算
<a class=anchor href=#%e6%97%a0%e7%b1%bb%e5%9e%8blambda%e6%bc%94%e7%ae%97>#</a></h2><p>无类型lambda演算含有以下三个组成部分</p><ul><li>term
<link rel=stylesheet href=/katex/katex.min.css><script defer src=/katex/katex.min.js></script><script defer src=/katex/auto-render.min.js onload=renderMathInElement(document.body)></script><span>\( t \)</span></li><li>abstraction <span>\( λx.t \)</span></li><li>application <span>\( t_1\ t_2 \)</span></li></ul><h3 id=example-1>Example 1
<a class=anchor href=#example-1>#</a></h3><p>$$
\begin{aligned}
& (λx.x) ((λx.x) (λz. (λx.x) z)) \\
\rightarrow & (λx.x) ((λx.x) (λz.z)) \\
\rightarrow & (λx.x) (λz.z) \\
\rightarrow & (λz.z) \\
\rightarrow & (λx.x) \\
\end{aligned}
$$</p><h2 id=简单类型lambda演算>简单类型lambda演算
<a class=anchor href=#%e7%ae%80%e5%8d%95%e7%b1%bb%e5%9e%8blambda%e6%bc%94%e7%ae%97>#</a></h2><p>简单类型lambda演算(<span>
\( \lambda_{\rightarrow} \)
</span>)含有以下五个组成部分</p><ul><li>term <span>\( t \)</span></li><li>abstraction <span>\( λx.t \)</span></li><li>application <span>\( t_1\ t_2 \)</span></li><li>type of functions <span>\( T_1\rightarrow T_2 \)</span></li><li>typing context <span>\( \Gamma \)</span></li></ul><h3 id=example-2>Example 2
<a class=anchor href=#example-2>#</a></h3><p>$$
\dfrac{\dfrac{\Gamma, x: T_1 \vdash t_1: T_2}{\Gamma \vdash \lambda x: T_1. t_1: T_1 \to T_2} \quad \quad \genfrac{}{}{0pt}{0}{}{\Gamma \vdash t_2: T_1}}{\Gamma \vdash \left(\lambda x: T_1. t_1\right) \ t_2: T_2}
$$</p><h2 id=含有子类型的简单类型lambda演算>含有子类型的简单类型lambda演算
<a class=anchor href=#%e5%90%ab%e6%9c%89%e5%ad%90%e7%b1%bb%e5%9e%8b%e7%9a%84%e7%ae%80%e5%8d%95%e7%b1%bb%e5%9e%8blambda%e6%bc%94%e7%ae%97>#</a></h2><blockquote><p><span>\( &lt;: \)
</span>笑脸可爱捏</p></blockquote><p>相比简单类型lambda演算(<span>
\( \lambda_{\rightarrow} \)
</span>)，唯独<strong>多出</strong>一个子类型(<span>
\( \lambda_{&lt;:} \)
</span>)的运算:</p><ul><li>subtyping <span>\( S &lt;: T \)</span></li></ul><p>如果 S 是 T 的子类型，意思是在任何需要使用 T 类型对象的环境中，都可以安全地使用 S 类型的对象。</p><h3 id=子类型的性质>子类型的性质
<a class=anchor href=#%e5%ad%90%e7%b1%bb%e5%9e%8b%e7%9a%84%e6%80%a7%e8%b4%a8>#</a></h3><ul><li>reflexive | 自反性 : <span>\( S &lt;: S \)</span></li><li>transitive | 传递性 : <span>\( \dfrac{S &lt;: U \qquad U &lt;: T}{S &lt;: T}\ \)</span></li><li>top and bottom | 上界与下界 : <span>\( \text{Bot} &lt;: S &lt;: \text{Top} \)</span></li></ul><p>目前为止还没有什么证明，要说明这里的第一条和第二条都很好理解，第三条是指上界和下界的存在性</p><h2 id=子类型型变>子类型型变
<a class=anchor href=#%e5%ad%90%e7%b1%bb%e5%9e%8b%e5%9e%8b%e5%8f%98>#</a></h2><p>这其实也是指的一组性质</p><ul><li>covariant | 协变 $$ \dfrac{S &lt;: T}{\text{list of } S &lt;: \text{list of } T} $$</li><li>contravariant | 逆变 $$ \dfrac{S &lt;: T}{T \to U &lt;: S \to U} $$</li><li>invariant | 不变 $$ \dfrac{S &lt;: T}{S \to S \text{ is neither subtype nor supertype of } T \to T} $$</li></ul><p>这里也是，协变和不变的性质很好理解，但逆变的性质就不是很好理解了</p><blockquote><p>接下来将对逆变给出一个并不严格的证明，或者说是说明</p></blockquote><p><strong>contravariant | 逆变</strong>：</p><p>翻译一下，S 是 T 的子类型，那么 “T到U的函数” 这个类型是 “S到U的函数” 这个类型的子类型</p><p>根据我们之前所提到的子类型的含义和逆变性质，我们现在来思考一下是否在任何需要使用 “S到U的函数” 类型对象的环境中，都可以安全地使用 “T到U的函数” 类型的对象。</p><p>从逻辑上来说并没有问题，根据多态，我需要用到 “S到U的函数” 的环境其实最后就是为了代入函数求值，但其实能代入 S 的实例化对象求值的场景，你把这个 “S到U的函数” 换成 “T到U的函数” 也能正常跑，完全没有任何问题</p><h2 id=应用-rust-类型系统的生命周期>应用: Rust 类型系统的生命周期
<a class=anchor href=#%e5%ba%94%e7%94%a8-rust-%e7%b1%bb%e5%9e%8b%e7%b3%bb%e7%bb%9f%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f>#</a></h2><p>观察如下一小段 Rust 代码</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> foo: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>u8</span> <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> bar <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>foo;
</span></span><span style=display:flex><span>        println!(<span style=color:#e6db74>&#34;bar = </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, <span style=color:#f92672>**</span>bar);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>熟悉 Rust 的朋友有可能在学习使用生命周期的时候接触过这段代码，但为了给更多人讲解，先让我们给它标记上更明显的生命周期标签</p><blockquote><p><strong>WARNING</strong>: 下面这一段代码是一段伪代码，Rust 编译器将不能编译它</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#a6e22e>&#39;b</span>: {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> foo: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>&#39;b</span> <span style=color:#66d9ef>u8</span> <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>&#39;a</span>: {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> bar: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>&#39;a</span> <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>&#39;b</span> <span style=color:#66d9ef>u8</span> <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>foo;
</span></span><span style=display:flex><span>            println!(<span style=color:#e6db74>&#34;bar = </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, <span style=color:#f92672>**</span>bar);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>此时此刻可以看到我们给外部作用域起一个生命周期的标签为 <code>'b</code> ，当然这里的标签是不能写在作用域前的，实际上被写在了第二行的 <code>foo</code> 变量的初始化中，这个标记意味着 <code>foo</code> 这个引用的生命周期是 <code>'b</code> ，而 <code>bar</code> 变量也是一样的，只是这边要强调一个点：<code>&'a &'b u8</code> 这个是<strong>引用的引用</strong>，<strong>隐式的要求 <code>'a</code> 要满足最多生命周期和 <code>'b</code> 一样长</strong></p><p>那这和我们上面的子类型有什么关系呢，我们看第二行：<code>let foo: &'b u8 = &amp;1;</code> ，其中 <code>&amp;1</code> 的生命周期在 Rust 中被规定为 <code>'static</code> 所以 <code>&amp;1</code> 的类型其实是 <code>&'static u8</code> ，而 <code>&'static u8</code> 可以赋给 <code>&'b u8</code> ，是为 <code>&'static u8</code> 为 <code>&'b u8</code> 的子类型</p><p>总结以下，在这里
<code>Bot = &'static T &lt;: &'b T &lt;: &'a T</code></p><p>接下来我们要提 Rust 中利用生命周期造就的经典的类型分析器的漏洞，在本文发布的时间点(2024.8.19)还未被修复</p><p><strong>Oops!</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>UNIT</span>: <span style=color:#66d9ef>&amp;</span>&#39;static <span style=color:#66d9ef>&amp;</span>&#39;static () <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;&amp;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>foo</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span>, <span style=color:#a6e22e>&#39;b</span>, T<span style=color:#f92672>&gt;</span>(_: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>&#39;a</span> <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>&#39;b</span> (), v: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>&#39;b</span> <span style=color:#a6e22e>T</span>) -&gt; <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>&#39;a</span> <span style=color:#a6e22e>T</span> { v }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>bad</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span>, T<span style=color:#f92672>&gt;</span>(x: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>&#39;a</span> <span style=color:#a6e22e>T</span>) -&gt; <span style=color:#66d9ef>&amp;</span>&#39;static <span style=color:#a6e22e>T</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> f: <span style=color:#a6e22e>fn</span>(_, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>&#39;a</span> T) -&gt; <span style=color:#66d9ef>&amp;</span>&#39;static <span style=color:#a6e22e>T</span> <span style=color:#f92672>=</span> foo;
</span></span><span style=display:flex><span>    f(<span style=color:#66d9ef>UNIT</span>, x)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可以看到 <code>bad</code> 函数很神奇的传入了一个 <code>&'a T</code> 类型的 <code>x</code> 却返回了 <code>&'static T</code> 的 <code>x</code>，这可了不得，这意味着你可以将一个引用的生命周期无端的延长，想象一下，这将不可避免的造成引用空悬，内存安全也就不存在了。众所周知，Rust 的一大亮点就是安全，但这段神奇的代码居然能“安全”的过编译</p><p>让我们来看看它是怎么工作的</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>foo</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span>, <span style=color:#a6e22e>&#39;b</span>, T<span style=color:#f92672>&gt;</span>(_: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>&#39;a</span> <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>&#39;b</span> (), v: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>&#39;b</span> <span style=color:#a6e22e>T</span>) -&gt; <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>&#39;a</span> <span style=color:#a6e22e>T</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>foo</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span>, <span style=color:#a6e22e>&#39;b</span>, T<span style=color:#f92672>&gt;</span>(_: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>&#39;a</span> <span style=color:#66d9ef>&amp;</span>&#39;static (), v: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>&#39;b</span> <span style=color:#a6e22e>T</span>) -&gt; <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>&#39;a</span> <span style=color:#a6e22e>T</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>foo</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;b</span>, T<span style=color:#f92672>&gt;</span>(_: <span style=color:#66d9ef>&amp;</span>&#39;static <span style=color:#66d9ef>&amp;</span>&#39;static (), v: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>&#39;b</span> <span style=color:#a6e22e>T</span>) -&gt; <span style=color:#66d9ef>&amp;</span>&#39;static <span style=color:#a6e22e>T</span>
</span></span></code></pre></div><p>上面这3行揭示了编译器在进行转换时发生的几个步骤：第一行是我们原来 <code>foo</code> 的标签，编译器首先将他转化为第二行，<code>&'a &'b ()</code> 转化为 <code>&'a &'static ()</code> ，因为 <code>&'a &'static ()</code> 是 <code>&'a &'b ()</code> 的子类型，那么根据逆变规则，这里的第一行的签名就是第二行的子类型，那么在任何需要使用第二行类型对象的环境中，都可以安全地使用第一行类型的对象。那么编译器便试图创建第二行的环境(因为你写的是 <code>_</code> ，要编译器去推导)，以适应你的 <code>foo</code> ，但是此时此刻，你告诉编译器 <code>'a</code> 是 <code>'static</code> ，编译器直接懵了，那就替换吧，于是借了编译器之手成就了天才的<strong>Lifetime_Expansion</strong></p><p>那么如何规避这个问题呢，其实关键就是这当中丢失了一个关键因素：第一行到第二行的时候丢失了一个 <code>&'a &'b ()</code> 包含的隐式的信息：<code>'a</code> 应该生命周期短于 <code>'b</code> ，而转化到第二步恰恰丢失了这一步信息，<code>'a</code> 和 <code>'b</code> 完全是两个无关的生命周期标签了</p><p>所以只要我们再给编译器一点提示，不至于让他绕进去就好了:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>//Manual solution
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>foo</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span>, <span style=color:#a6e22e>&#39;b</span>, T<span style=color:#f92672>&gt;</span>(_: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>&#39;a</span> <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>&#39;b</span> (), v: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>&#39;b</span> <span style=color:#a6e22e>T</span>) -&gt; <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>&#39;a</span> <span style=color:#a6e22e>T</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>where</span> <span style=color:#a6e22e>&#39;b</span>: <span style=color:#a6e22e>&#39;a</span>
</span></span></code></pre></div><p>当我们告诉编译器 <code>'b</code> 与 <code>'a</code> 之间的偏序关系，即表示 <code>'b</code> 至少要活得跟 <code>'a</code> 一样久。</p><blockquote><p>值得注意的是，这只是一个类型分析器的 bug ，当你试图将 <code>_</code> 省略的内容写清楚，也会使得这个 bug 消除</p></blockquote><p><a href=https://github.com/Speykious/cve-rs>cve-rs</a> 正是利用了这点，在完全不含 unsafe 块的 Rust 代码中引入了 segmentfault 等内存错误，<del>这太有乐子了</del>。</p><hr><p>作者：Github @NKID00</p><p>增改：Github @feipiao594</p><p>参考文献：</p><p>[1]. Github repo: cve-rs <a href=https://github.com/Speykious/cve-rs>https://github.com/Speykious/cve-rs</a></p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#无类型lambda演算>无类型lambda演算</a><ul><li><a href=#example-1>Example 1</a></li></ul></li><li><a href=#简单类型lambda演算>简单类型lambda演算</a><ul><li><a href=#example-2>Example 2</a></li></ul></li><li><a href=#含有子类型的简单类型lambda演算>含有子类型的简单类型lambda演算</a><ul><li><a href=#子类型的性质>子类型的性质</a></li></ul></li><li><a href=#子类型型变>子类型型变</a></li><li><a href=#应用-rust-类型系统的生命周期>应用: Rust 类型系统的生命周期</a></li></ul></nav></div></aside></main></body></html>